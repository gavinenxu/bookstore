module.exports = {
  // Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
  typeDefs:
    // Please don't change this file manually but run `prisma generate` to update it.
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

    /* GraphQL */ `
      type AggregateAuthor {
        count: Int!
      }

      type AggregateBook {
        count: Int!
      }

      type AggregateId {
        count: Int!
      }

      type Author {
        _id: Id!
        role: Int!
      }

      type AuthorConnection {
        pageInfo: PageInfo!
        edges: [AuthorEdge]!
        aggregate: AggregateAuthor!
      }

      input AuthorCreateInput {
        _id: IdCreateOneInput!
        role: Int!
      }

      input AuthorCreateManyInput {
        create: [AuthorCreateInput!]
      }

      type AuthorEdge {
        node: Author!
        cursor: String!
      }

      enum AuthorOrderByInput {
        role_ASC
        role_DESC
        id_ASC
        id_DESC
        createdAt_ASC
        createdAt_DESC
        updatedAt_ASC
        updatedAt_DESC
      }

      type AuthorPreviousValues {
        role: Int!
      }

      type AuthorSubscriptionPayload {
        mutation: MutationType!
        node: Author
        updatedFields: [String!]
        previousValues: AuthorPreviousValues
      }

      input AuthorSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: AuthorWhereInput
        AND: [AuthorSubscriptionWhereInput!]
        OR: [AuthorSubscriptionWhereInput!]
        NOT: [AuthorSubscriptionWhereInput!]
      }

      input AuthorUpdateManyMutationInput {
        role: Int
      }

      input AuthorWhereInput {
        _id: IdWhereInput
        role: Int
        role_not: Int
        role_in: [Int!]
        role_not_in: [Int!]
        role_lt: Int
        role_lte: Int
        role_gt: Int
        role_gte: Int
        AND: [AuthorWhereInput!]
        OR: [AuthorWhereInput!]
        NOT: [AuthorWhereInput!]
      }

      type BatchPayload {
        count: Long!
      }

      type Book {
        _id: Id!
        primary_isbn: String!
        authors(
          where: AuthorWhereInput
          orderBy: AuthorOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Author!]
      }

      type BookConnection {
        pageInfo: PageInfo!
        edges: [BookEdge]!
        aggregate: AggregateBook!
      }

      input BookCreateInput {
        _id: IdCreateOneInput!
        primary_isbn: String!
        authors: AuthorCreateManyInput
      }

      type BookEdge {
        node: Book!
        cursor: String!
      }

      enum BookOrderByInput {
        primary_isbn_ASC
        primary_isbn_DESC
        id_ASC
        id_DESC
        createdAt_ASC
        createdAt_DESC
        updatedAt_ASC
        updatedAt_DESC
      }

      type BookPreviousValues {
        primary_isbn: String!
      }

      type BookSubscriptionPayload {
        mutation: MutationType!
        node: Book
        updatedFields: [String!]
        previousValues: BookPreviousValues
      }

      input BookSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: BookWhereInput
        AND: [BookSubscriptionWhereInput!]
        OR: [BookSubscriptionWhereInput!]
        NOT: [BookSubscriptionWhereInput!]
      }

      input BookUpdateManyMutationInput {
        primary_isbn: String
      }

      input BookWhereInput {
        _id: IdWhereInput
        primary_isbn: String
        primary_isbn_not: String
        primary_isbn_in: [String!]
        primary_isbn_not_in: [String!]
        primary_isbn_lt: String
        primary_isbn_lte: String
        primary_isbn_gt: String
        primary_isbn_gte: String
        primary_isbn_contains: String
        primary_isbn_not_contains: String
        primary_isbn_starts_with: String
        primary_isbn_not_starts_with: String
        primary_isbn_ends_with: String
        primary_isbn_not_ends_with: String
        authors_every: AuthorWhereInput
        authors_some: AuthorWhereInput
        authors_none: AuthorWhereInput
        AND: [BookWhereInput!]
        OR: [BookWhereInput!]
        NOT: [BookWhereInput!]
      }

      type Id {
        oid: ID!
      }

      type IdConnection {
        pageInfo: PageInfo!
        edges: [IdEdge]!
        aggregate: AggregateId!
      }

      input IdCreateInput {
        oid: ID!
      }

      input IdCreateOneInput {
        create: IdCreateInput
        connect: IdWhereUniqueInput
      }

      type IdEdge {
        node: Id!
        cursor: String!
      }

      enum IdOrderByInput {
        oid_ASC
        oid_DESC
        id_ASC
        id_DESC
        createdAt_ASC
        createdAt_DESC
        updatedAt_ASC
        updatedAt_DESC
      }

      type IdPreviousValues {
        oid: ID!
      }

      type IdSubscriptionPayload {
        mutation: MutationType!
        node: Id
        updatedFields: [String!]
        previousValues: IdPreviousValues
      }

      input IdSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: IdWhereInput
        AND: [IdSubscriptionWhereInput!]
        OR: [IdSubscriptionWhereInput!]
        NOT: [IdSubscriptionWhereInput!]
      }

      input IdUpdateInput {
        oid: ID
      }

      input IdUpdateManyMutationInput {
        oid: ID
      }

      input IdWhereInput {
        oid: ID
        oid_not: ID
        oid_in: [ID!]
        oid_not_in: [ID!]
        oid_lt: ID
        oid_lte: ID
        oid_gt: ID
        oid_gte: ID
        oid_contains: ID
        oid_not_contains: ID
        oid_starts_with: ID
        oid_not_starts_with: ID
        oid_ends_with: ID
        oid_not_ends_with: ID
        AND: [IdWhereInput!]
        OR: [IdWhereInput!]
        NOT: [IdWhereInput!]
      }

      input IdWhereUniqueInput {
        oid: ID
      }

      scalar Long

      type Mutation {
        createAuthor(data: AuthorCreateInput!): Author!
        updateManyAuthors(
          data: AuthorUpdateManyMutationInput!
          where: AuthorWhereInput
        ): BatchPayload!
        deleteManyAuthors(where: AuthorWhereInput): BatchPayload!
        createBook(data: BookCreateInput!): Book!
        updateManyBooks(
          data: BookUpdateManyMutationInput!
          where: BookWhereInput
        ): BatchPayload!
        deleteManyBooks(where: BookWhereInput): BatchPayload!
        createId(data: IdCreateInput!): Id!
        updateId(data: IdUpdateInput!, where: IdWhereUniqueInput!): Id
        updateManyIds(
          data: IdUpdateManyMutationInput!
          where: IdWhereInput
        ): BatchPayload!
        upsertId(
          where: IdWhereUniqueInput!
          create: IdCreateInput!
          update: IdUpdateInput!
        ): Id!
        deleteId(where: IdWhereUniqueInput!): Id
        deleteManyIds(where: IdWhereInput): BatchPayload!
      }

      enum MutationType {
        CREATED
        UPDATED
        DELETED
      }

      interface Node {
        id: ID!
      }

      type PageInfo {
        hasNextPage: Boolean!
        hasPreviousPage: Boolean!
        startCursor: String
        endCursor: String
      }

      type Query {
        authors(
          where: AuthorWhereInput
          orderBy: AuthorOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Author]!
        authorsConnection(
          where: AuthorWhereInput
          orderBy: AuthorOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): AuthorConnection!
        books(
          where: BookWhereInput
          orderBy: BookOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Book]!
        booksConnection(
          where: BookWhereInput
          orderBy: BookOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): BookConnection!
        id(where: IdWhereUniqueInput!): Id
        ids(
          where: IdWhereInput
          orderBy: IdOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Id]!
        idsConnection(
          where: IdWhereInput
          orderBy: IdOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): IdConnection!
        node(id: ID!): Node
      }

      type Subscription {
        author(where: AuthorSubscriptionWhereInput): AuthorSubscriptionPayload
        book(where: BookSubscriptionWhereInput): BookSubscriptionPayload
        id(where: IdSubscriptionWhereInput): IdSubscriptionPayload
      }
    `
};
